name: Manual Deploy to ECS

on:
  workflow_dispatch:
    inputs:
      deploy-to:
        description: デプロイ先環境名
        type: environment
        default: development
      branch:
        description: デプロイブランチ名
        type: string
        required: true

env:
  AWS_REGION: "ap-northeast-1"

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ inputs.deploy-to }}
    steps:
      - name: Determine assume role
        id: determine-assume-role
        run: echo "GITHUB_ACTIONS_ROLE_ARN=${{ 'arn:aws:iam::' }}${{ secrets.AWS_ACCOUNT_ID }}${{ ':role/' }}${{ vars.CFN_STACK_NAME }}${{ '-GitHubActionsRole' }}" >> "${GITHUB_ENV}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: false
  
      # 動的パラメータの解決
      - name: Resolve dynamic params
        env:
          ECR_REPO_URI_OUTPUT_KEY: "EcrRepositoryUri"
          ECS_CLUSTER_ARN_OUTPUT_KEY: "EcsClusterArn"
          ECS_BACKEND_SERVICE_NAME_OUTPUT_KEY: "BackendEcsServiceName"
        run: |
          ECR_REPO_URI=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECR_REPO_URI_OUTPUT_KEY }}'].OutputValue"`
          echo "ECR_REPO_URI=${ECR_REPO_URI}" >> $GITHUB_ENV
          
          echo "ECR_REPOSITORY_NAME=${ECR_REPO_URI#*/}" >> $GITHUB_ENV
          
          ECS_CLUSTER_ARN=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECS_CLUSTER_ARN_OUTPUT_KEY }}'].OutputValue"`
          echo "ECS_CLUSTER_ARN=${ECS_CLUSTER_ARN}" >> $GITHUB_ENV
          
          ECS_BACKEND_SERVICE_NAME=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECS_BACKEND_SERVICE_NAME_OUTPUT_KEY }}'].OutputValue"`
          echo "ECS_BACKEND_SERVICE_NAME=${ECS_BACKEND_SERVICE_NAME}" >> $GITHUB_ENV
          
          echo "BUILD_VERSION=${GITHUB_SHA}(${GITHUB_RUN_NUMBER})" >> $GITHUB_ENV
          echo "BUILD_HASH=${GITHUB_SHA}" >> $GITHUB_ENV
    outputs:
      CFN_STACK_NAME: ${{vars.CFN_STACK_NAME}}
      env_name: ${{env.env_name}}
      GITHUB_ACTIONS_ROLE_ARN: ${{ env.GITHUB_ACTIONS_ROLE_ARN }}
      ECR_REPO_URI: ${{env.ECR_REPO_URI}}
      ECR_REPOSITORY_NAME: ${{env.ECR_REPOSITORY_NAME}}
      ECS_CLUSTER_ARN: ${{env.ECS_CLUSTER_ARN}}
      ECS_BACKEND_SERVICE_NAME: ${{env.ECS_BACKEND_SERVICE_NAME}}
      BUILD_VERSION: ${{env.BUILD_VERSION}}
      BUILD_HASH: ${{env.BUILD_HASH}}

  build-and-push-app-image:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Build and push app image
        uses: docker/build-push-action@v4
        with:
          context: ./cloud-formation/ecs/docker/php
          push: true
          provenance: false
          tags: ${{ env.ECR_REPO_URI }}:${{ github.run_number }}-app
          cache-from: type=gha,scope=app
          cache-to: type=gha,mode=max,scope=app

  build-and-push-web-image:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Build add push web image
        uses: docker/build-push-action@v4
        env:
          BACKEND_APP_DOMAIN: "127.0.0.1"
          RESOLVER: "169.254.169.253"
        with:
          context: ./cloud-formation/ecs/docker/nginx
          push: true
          provenance: false
          tags: ${{ env.ECR_REPO_URI }}:${{ github.run_number }}-web
          cache-from: type=gha,scope=web
          cache-to: type=gha,mode=max,scope=web
          build-args: |
            BACKEND_APP_DOMAIN
            RESOLVER

  delivery:
    runs-on: ubuntu-latest
    needs: [ "setup", "build-and-push-app-image", "build-and-push-web-image" ]
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ inputs.deploy-to }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr

      - name: Delivery
        run: |
          MANIFEST_APP=$(aws ecr batch-get-image --registry-id ${{ secrets.AWS_ACCOUNT_ID }} --repository-name ${{needs.setup.outputs.ECR_REPOSITORY_NAME}} --image-ids imageTag=${GITHUB_RUN_NUMBER}-app --output json | jq --raw-output --join-output '.images[0].imageManifest')
          MANIFEST_WEB=$(aws ecr batch-get-image --registry-id ${{ secrets.AWS_ACCOUNT_ID }} --repository-name ${{needs.setup.outputs.ECR_REPOSITORY_NAME}} --image-ids imageTag=${GITHUB_RUN_NUMBER}-web --output json | jq --raw-output --join-output '.images[0].imageManifest')

          aws ecr put-image --registry-id ${{ secrets.AWS_ACCOUNT_ID }} \
            --repository-name ${{needs.setup.outputs.ECR_REPOSITORY_NAME}} \
            --image-tag app --image-manifest "${MANIFEST_APP}" > app_log 2>&1 || {
              if [ $? -eq 254 ] && fgrep -q 'ImageAlreadyExistsException' app_log ; then
                echo "Catch ImageAlreadyExistsException on app image deploy. It is OK, Ignored"
                true
              else
                cat app_log
                false
              fi
            }

          aws ecr put-image --registry-id ${{ secrets.AWS_ACCOUNT_ID }} \
            --repository-name ${{needs.setup.outputs.ECR_REPOSITORY_NAME}} \
            --image-tag web --image-manifest "${MANIFEST_WEB}" > web_log 2>&1 || {
              if [ $? -eq 254 ] && fgrep -q 'ImageAlreadyExistsException' web_log ; then
                echo "Catch ImageAlreadyExistsException on web image deploy. It is OK, Ignored"
                true
              else
                cat web_log
                false
              fi
            }
          
          aws ecs update-service \
          --cluster ${{ needs.setup.outputs.ECS_CLUSTER_ARN }} \
          --service ${{ needs.setup.outputs.ECS_BACKEND_SERVICE_NAME }} \
          --force-new-deployment
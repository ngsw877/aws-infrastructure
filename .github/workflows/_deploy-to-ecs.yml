name: Deploy to ECS

on:
  workflow_call:
    inputs:
      deploy-to:
        description: デプロイ先環境
        type: string
        required: false
        default: ${{ github.ref_name }}
      branch:
        description: デプロイ対象ブランチ名
        type: string
        required: false
        default: ${{ github.ref_name }}

env:
  AWS_REGION: "ap-northeast-1"

defaults:
  run:
    shell: bash

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ inputs.deploy-to }}
    steps:
      - name: Determine assume role
        id: determine-assume-role
        run: echo "GITHUB_ACTIONS_ROLE_ARN=${{ 'arn:aws:iam::' }}${{ vars.AWS_ACCOUNT_ID }}${{ ':role/' }}${{ vars.CFN_STACK_NAME }}${{ '-GitHubActionsRole' }}" >> "${GITHUB_ENV}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: false
  
      # 動的パラメータの解決
      - name: Resolve dynamic params
        env:
          ECR_REPO_URI_OUTPUT_KEY: "EcrRepositoryUri"
          ECS_CLUSTER_ARN_OUTPUT_KEY: "EcsClusterArn"
          ECS_BACKEND_SERVICE_NAME_OUTPUT_KEY: "BackendEcsServiceName"
        run: |
          ECR_REPO_URI=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECR_REPO_URI_OUTPUT_KEY }}'].OutputValue"`
          echo "ECR_REPO_URI=${ECR_REPO_URI}" >> $GITHUB_ENV
          
          echo "ECR_REPOSITORY_NAME=${ECR_REPO_URI#*/}" >> $GITHUB_ENV
          
          ECS_CLUSTER_ARN=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECS_CLUSTER_ARN_OUTPUT_KEY }}'].OutputValue"`
          echo "ECS_CLUSTER_ARN=${ECS_CLUSTER_ARN}" >> $GITHUB_ENV
          
          ECS_BACKEND_SERVICE_NAME=`aws cloudformation describe-stacks --stack-name ${{ vars.CFN_STACK_NAME }} --output text --query "Stacks[].Outputs[?OutputKey=='${{ env.ECS_BACKEND_SERVICE_NAME_OUTPUT_KEY }}'].OutputValue"`
          echo "ECS_BACKEND_SERVICE_NAME=${ECS_BACKEND_SERVICE_NAME}" >> $GITHUB_ENV
          
          BUILD_VERSION="${GITHUB_SHA}-${GITHUB_RUN_NUMBER}"
          echo "::notice::BUILD_VERSION is ${BUILD_VERSION}"

          APP_IMAGE_TAG="app-${BUILD_VERSION}"
          echo "APP_IMAGE_TAG=${APP_IMAGE_TAG}" >> $GITHUB_ENV

          WEB_IMAGE_TAG="web-${BUILD_VERSION}"
          echo "WEB_IMAGE_TAG=${WEB_IMAGE_TAG}" >> $GITHUB_ENV
    outputs:
      GITHUB_ACTIONS_ROLE_ARN: ${{ env.GITHUB_ACTIONS_ROLE_ARN }}
      ECR_REPO_URI: ${{ env.ECR_REPO_URI }}
      ECR_REPOSITORY_NAME: ${{ env.ECR_REPOSITORY_NAME }}
      ECS_CLUSTER_ARN: ${{ env.ECS_CLUSTER_ARN }}
      ECS_BACKEND_SERVICE_NAME: ${{ env.ECS_BACKEND_SERVICE_NAME }}
      APP_IMAGE_TAG: ${{ env.APP_IMAGE_TAG }}
      WEB_IMAGE_TAG: ${{ env.WEB_IMAGE_TAG }}

  build-and-push-app-image:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Build and push app image
        uses: docker/build-push-action@v4
        with:
          context: ./cloud-formation/ecs/docker/php
          push: true
          provenance: false
          tags: ${{ needs.setup.outputs.ECR_REPO_URI }}:${{ needs.setup.outputs.APP_IMAGE_TAG }}
          cache-from: type=gha,scope=app
          cache-to: type=gha,mode=max,scope=app

  build-and-push-web-image:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Build add push web image
        uses: docker/build-push-action@v4
        env:
          BACKEND_APP_DOMAIN: "127.0.0.1"
          RESOLVER: "169.254.169.253"
        with:
          context: ./cloud-formation/ecs/docker/nginx
          push: true
          provenance: false
          tags: ${{needs.setup.outputs.ECR_REPO_URI}}:${{ needs.setup.outputs.WEB_IMAGE_TAG }}
          cache-from: type=gha,scope=web
          cache-to: type=gha,mode=max,scope=web
          build-args: |
            BACKEND_APP_DOMAIN
            RESOLVER

  delivery:
    runs-on: ubuntu-latest
    needs: [ "setup", "build-and-push-app-image", "build-and-push-web-image" ]
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ inputs.deploy-to }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ needs.setup.outputs.GITHUB_ACTIONS_ROLE_ARN }}
          role-skip-session-tagging: true
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr

      - name: Delivery
        run: |
          MANIFEST_APP=$(aws ecr batch-get-image --registry-id ${{ vars.AWS_ACCOUNT_ID }} --repository-name ${{ needs.setup.outputs.ECR_REPOSITORY_NAME }} --image-ids imageTag=${{ needs.setup.outputs.APP_IMAGE_TAG }} --output json | jq --raw-output --join-output '.images[0].imageManifest')
          MANIFEST_WEB=$(aws ecr batch-get-image --registry-id ${{ vars.AWS_ACCOUNT_ID }} --repository-name ${{ needs.setup.outputs.ECR_REPOSITORY_NAME }} --image-ids imageTag=${{ needs.setup.outputs.WEB_IMAGE_TAG }} --output json | jq --raw-output --join-output '.images[0].imageManifest')

          aws ecr put-image --registry-id ${{ vars.AWS_ACCOUNT_ID }} \
            --repository-name ${{ needs.setup.outputs.ECR_REPOSITORY_NAME }} \
            --image-tag app --image-manifest "${MANIFEST_APP}" > app_log 2>&1 || {
              if [ $? -eq 254 ] && fgrep -q 'ImageAlreadyExistsException' app_log ; then
                echo "Catch ImageAlreadyExistsException on app image deploy. It is OK, Ignored"
                true
              else
                cat app_log
                false
              fi
            }

          aws ecr put-image --registry-id ${{ vars.AWS_ACCOUNT_ID }} \
            --repository-name ${{ needs.setup.outputs.ECR_REPOSITORY_NAME }} \
            --image-tag web --image-manifest "${MANIFEST_WEB}" > web_log 2>&1 || {
              if [ $? -eq 254 ] && fgrep -q 'ImageAlreadyExistsException' web_log ; then
                echo "Catch ImageAlreadyExistsException on web image deploy. It is OK, Ignored"
                true
              else
                cat web_log
                false
              fi
            }
          
          aws ecs update-service \
          --cluster ${{ needs.setup.outputs.ECS_CLUSTER_ARN }} \
          --service ${{ needs.setup.outputs.ECS_BACKEND_SERVICE_NAME }} \
          --force-new-deployment